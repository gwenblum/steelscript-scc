# Copyright (c) 2015 Riverbed Technology, Inc.
#
# This software is licensed under the terms and conditions of the MIT License
# accompanying the software ("License").  This software is distributed "AS IS"
# as set forth in the License.

import logging

from steelscript.netprofiler.core.filters import TimeFilter
from steelscript.common.timeutils import datetime_to_seconds


__all__ = ['BWUsageStatsReport',
           'BWTimeSeriesStatsReport',
           'BWPerApplStatsReport',
           'ThroughputStatsReport',
           'ThroughputPerApplStatsReport',
           'ConnectionHistoryStatsReport',
           'ConnectionPoolingStatsReport',
           'ConnectionForwardingStatsReport',
           'HTTPStatsReport',
           'NFSStatsReport',
           'SSLStatsReport',
           'DiskLoadStatsReport',
           'DNSUsageStatsReport',
           'DNSCacheHitsStatsReport',
           'SDRAdaptiveStatsReport',
           'MemoryPagingStatsReport',
           'CpuUtilizationStatsReport',
           'PFSStatsReport',
           'SRDFStatsReport',
           'TCPMemoryPressureReport',
           'QoSStatsReport',
           'SnapMirrorStatsReport',
           'SteelFusionLUNIOReport',
           'SteelFusionInitiatorIOReport',
           'SteelFusionNetworkIOReport',
           'SteelFusionBlockstoreReport']

logger = logging.getLogger(__name__)


class SCCException(Exception):
    pass


class Report(object):
    """Base class for SCC reports"""
    def __init__(self, scc):
        self.scc = scc
        self.datarep = None
        self.response = None
        self.data = None

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if any([type, value, traceback]):
            logger.exception("Exception in running %s" %
                             self.__class__.__name__)


class BaseStatsReport(Report):
    """Base class for reports generated by scc.stats api, can not be directly
    used for creating reports objects. All report instances are derived based
    on sub-classes inheriting from this class.

    :param required_fields: list of fields required by the sub-report,
        excluding start_time and end_time.
    :param non_required_fields: list of fields available to use but not
        required by the sub-report
    :param resource: string, name of the resource
    """

    required_fields = []
    non_required_fields = []
    resource = None

    def __init__(self, scc):
        super(BaseStatsReport, self).__init__(scc)
        self.criteria = {}

    def _fill_criteria(self, **kwargs):
        # Ensure all passed-in params are valid params
        valid_fields = (['timefilter'] + self.required_fields +
                        self.non_required_fields)

        for field in kwargs:
            if field not in valid_fields:
                raise SCCException("Criteria '%s' is not a valid field for %s"
                                   % (field, self.__class__.__name__))

        if 'timefilter' not in kwargs or kwargs['timefilter'] is None:
            timefilter = TimeFilter.parse_range("last 1 hour")
        else:
            timefilter = TimeFilter.parse_range(kwargs['timefilter'])

        start = datetime_to_seconds(timefilter.start)
        end = datetime_to_seconds(timefilter.end)
        self.criteria['start_time'] = int(start)
        self.criteria['end_time'] = int(end)

        if 'devices' in kwargs and kwargs['devices']:
            kwargs['devices'] = kwargs['devices'].split(',')

        if 'port' in kwargs and kwargs['port']:
            kwargs['port'] = int(kwargs['port'])

        # Adding required fields to criteria
        for field in self.required_fields:
            if field not in kwargs:
                raise SCCException('Field %s is required to run %s' %
                                   (field, self.__class__.__name__))
            self.criteria[field] = kwargs[field]

        # Adding non-required fields to criteria
        for field in self.non_required_fields:
            if field in kwargs and kwargs[field]:
                self.criteria[field] = kwargs[field]

    def run(self, **kwargs):
        """Run report to fetch data from the SCC device"""
        self._fill_criteria(**kwargs)
        self.datarep = self.scc.stats.bind(self.resource)
        self.response = self.datarep.execute(self.link, self.criteria)
        if (self.response_key and isinstance(self.response.data, dict) and
                self.response_key in self.response.data):
            self.data = self.response.data[self.response_key]
        else:
            self.data = self.response.data

#
# Bandwidth Reports
#


class BWStatsReport(BaseStatsReport):
    non_required_fields = ['traffic_type', 'port', 'devices']


class BWUsageStatsReport(BWStatsReport):
    """Report class to return bandwidth usage"""
    resource = 'bw_usage'
    link = 'report'
    response_key = 'response_data'


class BWTimeSeriesStatsReport(BWStatsReport):
    """Report class to return bandwidth timeseries"""
    resource = 'bw_timeseries'
    link = 'report'
    response_key = 'response_data'


class BWPerApplStatsReport(BaseStatsReport):
    """Report class to return the bandwidth per appliance data"""
    required_fields = ['devices']
    non_required_fields = ['traffic_type']
    resource = 'bw_per_appliance'
    link = 'report'
    response_key = 'response_data'

#
# Throughput Reports
#


class ThroughputStatsReport(BaseStatsReport):
    """Report class to return the peak/p95 throughput timeseries"""
    required_fields = ['device']
    non_required_fields = ['traffic_type', 'port']
    resource = 'throughput'
    link = 'report'
    response_key = 'response_data'


class ThroughputPerApplStatsReport(BaseStatsReport):
    """Report class to return the throughput per appliance data"""
    required_fields = ['devices']
    non_required_fields = ['traffic_type']
    resource = 'throughput_per_appliance'
    link = 'report'
    response_key = 'response_data'

#
# Timeseries Reports for Single Device
#


class TimeseriesStatsReport(BaseStatsReport):
    required_fields = ['device']
    non_required_fields = ['traffic_type']
    link = 'report'
    response_key = 'response_data'


class ConnectionHistoryStatsReport(TimeseriesStatsReport):
    """Report class to return the max/avg connection history timeseries"""
    resource = 'connection_history'
    link = 'report'
    response_key = 'response_data'


class SRDFStatsReport(TimeseriesStatsReport):
    """Report class to return the regular/peak srdf timeseries"""
    resource = 'srdf'
    link = 'report'
    response_key = 'response_data'


class TCPMemoryPressureReport(TimeseriesStatsReport):
    """Report class to return regular/peak tcp memory pressure timesries"""
    resource = 'tcp_memory_pressure'
    link = 'report'
    response_key = 'response_data'

#
# Multiple Devices Reports
#


class MultiDevStatsReport(BaseStatsReport):
    non_required_fields = ['devices']
    link = 'report'
    response_key = 'response_data'


class ConnectionPoolingStatsReport(MultiDevStatsReport):
    """Report class to return the connection pooling timeseries"""
    resource = 'connection_pooling'
    link = 'report'
    response_key = 'response_data'


class ConnectionForwardingStatsReport(MultiDevStatsReport):
    """Report class to return the connection forwrding timeseries"""
    resource = 'connection_forwarding'
    link = 'report'
    response_key = 'response_data'


class DNSUsageStatsReport(MultiDevStatsReport):
    """Report class to return the dns usage timeseries"""
    resource = 'dns_usage'
    link = 'report'
    response_key = 'response_data'


class DNSCacheHitsStatsReport(MultiDevStatsReport):
    """Report class to return the dns cache hits timeseries"""
    resource = 'dns_cache_hits'
    link = 'report'
    response_key = 'response_data'


class HTTPStatsReport(MultiDevStatsReport):
    """Report class to return the http timeseries"""
    resource = 'http'
    link = 'report'
    response_key = 'response_data'


class NFSStatsReport(MultiDevStatsReport):
    """Report class to return the nfs timeseries"""
    resource = 'nfs'
    link = 'report'
    response_key = 'response_data'


class SSLStatsReport(MultiDevStatsReport):
    """Report class to return the ssl timeseries"""
    resource = 'ssl'
    link = 'report'
    response_key = 'response_data'


class DiskLoadStatsReport(MultiDevStatsReport):
    """Report class to return disk load timeseries"""
    resource = 'disk_load'
    link = 'report'
    response_key = 'response_data'

#
# Single Device Reports
#


class SingleDevStatsReport(BaseStatsReport):
    required_fields = ['device']
    link = 'report'
    response_key = 'response_data'


class SDRAdaptiveStatsReport(SingleDevStatsReport):
    """Report class to return the SDR Adaptive timeseries"""
    resource = 'sdr_adaptive'
    link = 'report'
    response_key = 'response_data'


class MemoryPagingStatsReport(SingleDevStatsReport):
    """Report class to return the memory paging timeseries"""
    resource = 'memory_paging'
    link = 'report'
    response_key = 'response_data'


class CpuUtilizationStatsReport(SingleDevStatsReport):
    """Report class to return the cpu utilization timeseries"""
    resource = 'cpu_utilization'
    link = 'report'
    response_key = 'response_data'


class PFSStatsReport(SingleDevStatsReport):
    """Report class to return the pfs timeseries"""
    resource = 'pfs'
    link = 'report'
    response_key = 'response_data'


#
# Qos Reports
#


class QoSStatsReport(BaseStatsReport):
    """Report class to return the outbound/inbound qos timeseries"""
    required_fields = ['device']
    non_required_fields = ['qos_class_id', 'traffic_type']
    resource = 'qos'
    link = 'report'
    response_key = 'response_data'


#
# Snapmirror Reports
#


class SnapMirrorStatsReport(BaseStatsReport):
    """Report class to return regular/peak snapmirror timeseries"""
    required_fields = ['device']
    non_required_fields = ['filer_id', 'traffic_type']
    resource = 'snapmirror'
    link = 'report'
    response_key = 'response_data'


#
# SteelFusion Reports
#


class SteelFusionLUNIOReport(BaseStatsReport):
    """Report class to return the SteelFusion lun io timeseries"""
    required_fields = ['device']
    non_required_fields = ['traffic_type', 'lun_subclass_id']
    resource = 'granite_lun_io'
    link = 'report'
    response_key = 'response_data'


class SteelFusionInitiatorIOReport(BaseStatsReport):
    """Report class to return the SteelFusion initiator io timeseries"""
    required_fields = ['device']
    non_required_fields = ['traffic_type', 'initiator_subclass_id']
    resource = 'granite_initiator_io'
    link = 'report'
    response_key = 'response_data'


class SteelFusionNetworkIOReport(TimeseriesStatsReport):
    """Report class to return the SteelFusion network IO timeseries"""
    resource = 'granite_network_io'
    link = 'report'
    response_key = 'response_data'


class SteelFusionBlockstoreReport(SteelFusionLUNIOReport):
    """Report class to return the SteelFusion blockstore timeseries"""
    resource = 'granite_blockstore'
    link = 'report'
    response_key = 'response_data'
