# Copyright (c) 2015 Riverbed Technology, Inc.
#
# This software is licensed under the terms and conditions of the MIT License
# accompanying the software ("License").  This software is distributed "AS IS"
# as set forth in the License.

import logging

from steelscript.netprofiler.core.filters import TimeFilter
from steelscript.common.timeutils import datetime_to_seconds


__all__ = ['BWUsageStatsReport',
           'BWTimeSeriesStatsReport',
           'BWPerApplStatsReport',
           'ThroughputStatsReport',
           'ThroughputPerApplStatsReport',
           'ConnectionHistoryStatsReport',
           'ConnectionPoolingStatsReport',
           'ConnectionForwardingStatsReport',
           'HTTPStatsReport',
           'NFSStatsReport',
           'SSLStatsReport',
           'DiskLoadStatsReport',
           'DNSUsageStatsReport',
           'DNSCacheHitsStatsReport',
           'SDRAdaptiveStatsReport',
           'MemoryPagingStatsReport',
           'CpuUtilizationStatsReport',
           'PFSStatsReport',
           'SRDFStatsReport',
           'TCPMemoryPressureReport',
           'QoSStatsReport',
           'SnapMirrorStatsReport',
           'GraniteLUNIOReport',
           'GraniteInitiatorIOReport',
           'GraniteNetworkIOReport',
           'GraniteBlockstoreReport']

logger = logging.getLogger(__name__)


class SCCException(Exception):
    pass


class Report(object):
    """Base class for SCC reports"""
    def __init__(self, scc):
        self.scc = scc

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if any([type, value, traceback]):
            logger.exception("Exception in running %s" % self.__class__)


class BaseStatsReport(Report):
    """Base class for reports generated by scc.stats api, can not be directly
    used for creating reports objects. All report instances are derived based
    on sub-classes inheriting from this class.

    :param required_fields: list of fields required by the sub-report,
        excluding start_time and end_time.
    :param non_required_fields: list of fields available to use but not
        required by the sub-report
    :param resource: string, name of the resource
    """

    required_fields = []
    non_required_fields = []
    resource = None

    def __init__(self, scc):
        super(BaseStatsReport, self).__init__(scc)
        self.criteria = {}

    def fill_criteria(self, **kwargs):

        if 'timefilter' not in kwargs or kwargs['timefilter'] is None:
            timefilter = TimeFilter.parse_range("last 1 hour")
        else:
            timefilter = TimeFilter.parse_range(kwargs['timefilter'])

        start = datetime_to_seconds(timefilter.start)
        end = datetime_to_seconds(timefilter.end)
        self.criteria['start_time'] = int(start)
        self.criteria['end_time'] = int(end)

        if 'devices' in kwargs and kwargs['devices']:
            kwargs['devices'] = kwargs['devices'].split(',')

        if 'port' in kwargs and kwargs['port']:
            kwargs['port'] = int(kwargs['port'])

        # Adding required fields to criteria
        for field in self.required_fields:
            if field not in kwargs:
                raise SCCException('Field %s is required to run %s' %
                                   (field, self.__class__))
            self.criteria[field] = kwargs[field]

        # Adding non-required fields to criteria
        for field in self.non_required_fields:
            if field in kwargs and kwargs[field]:
                self.criteria[field] = kwargs[field]

    def run(self, **kwargs):
        self.fill_criteria(**kwargs)
        data_rep = self.scc.bind(self.resource)
        resp = data_rep.execute('report', self.criteria)
        self.data = resp.data['response_data']

"""
Reports for bandwidth data for time-series and per port bandwidth usage
"""


class BWStatsReport(BaseStatsReport):
    non_required_fields = ['traffic_type', 'port', 'devices']

    def run(self, traffic_type=None, timefilter=None, port=None,
            devices=None):
        super(BWStatsReport, self).run(timefilter=timefilter,
                                       traffic_type=traffic_type,
                                       port=port,
                                       devices=devices)


class BWUsageStatsReport(BWStatsReport):
    """Report class to return bandwidth usage"""
    resource = 'bw_usage'


class BWTimeSeriesStatsReport(BWStatsReport):
    """Report class to return bandwidth timeseries"""
    resource = 'bw_timeseries'


class BWPerApplStatsReport(BaseStatsReport):
    """Report class to return the bandwidth per appliance data"""
    required_fields = ['devices']
    non_required_fields = ['traffic_type']
    resource = 'bw_per_appliance'

    def run(self, timefilter=None, devices=None, traffic_type=None):
        super(BWPerApplStatsReport, self).run(timefilter=timefilter,
                                              devices=devices,
                                              traffic_type=traffic_type)

"""
Throughput Reports
"""


class ThroughputStatsReport(BaseStatsReport):
    """Report class to return the peak/p95 throughput timeseries"""
    required_fields = ['device']
    non_required_fields = ['traffic_type', 'port']
    resource = 'throughput'

    def run(self, device=None, timefilter=None,  traffic_type=None, port=None):
        super(ThroughputStatsReport, self).run(device=device,
                                               timefilter=timefilter,
                                               traffic_type=traffic_type,
                                               port=port)


class ThroughputPerApplStatsReport(BaseStatsReport):
    """Report class to return the throughput per appliance data"""
    required_fields = ['devices']
    non_required_fields = ['traffic_type']
    resource = 'throughput_per_appliance'

    def run(self, devices=None, timefilter=None,  traffic_type=None):
        super(ThroughputPerApplStatsReport, self).run(
            devices=devices, timefilter=timefilter, traffic_type=traffic_type)

"""
Reports for data of a single device based on traffic_type
"""


class RegPeakTrafficStatsReport(BaseStatsReport):
    required_fields = ['device']
    non_required_fields = ['traffic_type']

    def run(self, timefilter=None, device=None, traffic_type=None):
        super(RegPeakTrafficStatsReport, self).run(timefilter=timefilter,
                                                   device=device,
                                                   traffic_type=traffic_type)


class ConnectionHistoryStatsReport(RegPeakTrafficStatsReport):
    """Report class to return the max/avg connection history timeseries"""
    resource = 'connection_history'


class SRDFStatsReport(RegPeakTrafficStatsReport):
    """Report class to return the regular/peak srdf timeseries"""
    resource = 'srdf'


class TCPMemoryPressureReport(RegPeakTrafficStatsReport):
    """Report class to return regular/peak tcp memory pressure timesries"""
    resource = 'tcp_memory_pressure'

"""
Reports for data about muliple devices, no traffic type specified
"""


class MultiDevStatsReport(BaseStatsReport):
    non_required_fields = ['devices']

    def run(self, timefilter=None, devices=None):
        super(MultiDevStatsReport, self).run(timefilter=timefilter,
                                             devices=devices)


class ConnectionPoolingStatsReport(MultiDevStatsReport):
    """Report class to return the connection pooling timeseries"""
    resource = 'connection_pooling'


class ConnectionForwardingStatsReport(MultiDevStatsReport):
    """Report class to return the connection forwrding timeseries"""
    resource = 'connection_forwarding'


class DNSUsageStatsReport(MultiDevStatsReport):
    """Report class to return the dns usage timeseries"""
    resource = 'dns_usage'


class DNSCacheHitsStatsReport(MultiDevStatsReport):
    """Report class to return the dns cache hits timeseries"""
    resource = 'dns_cache_hits'


class HTTPStatsReport(MultiDevStatsReport):
    """Report class to return the http timeseries"""
    resource = 'http'


class NFSStatsReport(MultiDevStatsReport):
    """Report class to return the nfs timeseries"""
    resource = 'nfs'


class SSLStatsReport(MultiDevStatsReport):
    """Report class to return the ssl timeseries"""
    resource = 'ssl'


class DiskLoadStatsReport(MultiDevStatsReport):
    """Report class to return disk load timeseries"""
    resource = 'disk_load'

"""
Reports for data about a single device, no traffic type specified
"""


class SingleDevStatsReport(BaseStatsReport):
    required_fields = ['device']

    def run(self, timefilter=None, device=None):
        super(SingleDevStatsReport, self).run(timefilter=timefilter,
                                              device=device)


class SDRAdaptiveStatsReport(SingleDevStatsReport):
    """Report class to return the SDR Adaptive timeseries"""
    resource = 'sdr_adaptive'


class MemoryPagingStatsReport(SingleDevStatsReport):
    """Report class to return the memory paging timeseries"""
    resource = 'memory_paging'


class CpuUtilizationStatsReport(SingleDevStatsReport):
    """Report class to return the cpu utilization timeseries"""
    resource = 'cpu_utilization'


class PFSStatsReport(SingleDevStatsReport):
    """Report class to return the pfs timeseries"""
    resource = 'pfs'


"""
Reports for querying Qos data.
"""


class QoSStatsReport(BaseStatsReport):
    """Report class to return the outbound/inbound qos timeseries"""
    required_fields = ['device']
    non_required_fields = ['qos_class_id', 'traffic_type']
    resource = 'qos'

    def run(self, timefilter=None, device=None,
            qos_class_id=None, traffic_type=None):
        super(QoSStatsReport, self).run(timefilter=timefilter,
                                        device=device,
                                        qos_class_id=qos_class_id,
                                        traffic_type=traffic_type)


"""
Reports for querying regular/peak data for a single device
"""


class SnapMirrorStatsReport(BaseStatsReport):
    """Report class to return regular/peak snapmirror timeseries"""
    required_fields = ['device']
    non_required_fields = ['filer_id', 'traffic_type']
    resource = 'snapmirror'

    def run(self, timefilter=None, device=None,
            filer_id=None, traffic_type=None):
        super(SnapMirrorStatsReport, self).run(timefilter=timefilter,
                                               device=device,
                                               filer_id=filer_id,
                                               traffic_type=traffic_type)


"""
Reports for SteelFusion data.
"""


class GraniteLUNIOReport(BaseStatsReport):
    """Report class to return the granite lun io timeseries"""
    required_fields = ['device']
    non_required_fields = ['traffic_type', 'lun_subclass_id']
    resource = 'granite_lun_io'

    def run(self, timefilter=None, device=None,
            lun_subclass_id=None, traffic_type=None):
        super(GraniteLUNIOReport, self).run(timefilter=timefilter,
                                            device=device,
                                            lun_subclass_id=lun_subclass_id,
                                            traffic_type=traffic_type)


class GraniteInitiatorIOReport(BaseStatsReport):
    """Report class to return the SteelFusion initiator io time-sereis"""
    required_fields = ['device']
    non_required_fields = ['traffic_type', 'initiator_subclass_id']
    resource = 'granite_initiator_io'

    def run(self, timefilter=None, device=None,
            initiator_subclass_id=None, traffic_type=None):
        super(GraniteInitiatorIOReport, self).run(
            timefilter=timefilter, device=device,
            initiator_subclass_id=initiator_subclass_id,
            traffic_type=traffic_type)


class GraniteNetworkIOReport(RegPeakTrafficStatsReport):
    """Report class to return the SteelFusion network IO timeseries"""
    resource = 'granite_network_io'


class GraniteBlockstoreReport(GraniteLUNIOReport):
    """Report class to return the SteelFusion blockstore timeseries"""
    resource = 'granite_blockstore'
